// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../src/TournamentManager.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// Malicious token that can execute callbacks on transfer
contract MaliciousToken is ERC20 {
    address public attacker;
    TournamentManager public target;
    uint256 public tournamentId;

    constructor(address _attacker) ERC20("Evil Token", "EVIL") {
        attacker = _attacker;
        _mint(attacker, 1_000_000 * 10 ** 18);
    }

    function setTarget(TournamentManager _target, uint256 _tournamentId) external {
        target = _target;
        tournamentId = _tournamentId;
    }

    // Override transfer to execute reentrancy attack
    function transfer(address to, uint256 amount) public override returns (bool) {
        if (to == address(target) && msg.sender == attacker) {
            // Normal transfer
            return super.transfer(to, amount);
        } else if (msg.sender == address(target)) {
            // This is called during prize distribution
            // Execute reentrancy attack here
            if (target.getTournamentWinners(tournamentId).length > 0) {
                try target.distributePrizes(tournamentId) {} catch {}
            }
            return super.transfer(to, amount);
        }
        return super.transfer(to, amount);
    }

    // Override transferFrom for similar attack vector
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        if (to == address(target) && from == attacker) {
            // Normal transferFrom during joining
            return super.transferFrom(from, to, amount);
        }
        return super.transferFrom(from, to, amount);
    }
}

// Attacker contract for reentrancy on ETH refunds
contract ReentrancyAttacker {
    TournamentManager public target;
    uint256 public tournamentId;
    uint256 public attackCount;
    uint256 public maxAttacks;

    constructor(TournamentManager _target) {
        target = _target;
    }

    function setup(uint256 _tournamentId, uint256 _maxAttacks) external {
        tournamentId = _tournamentId;
        maxAttacks = _maxAttacks;
        attackCount = 0;
    }

    function register() external {
        target.registerPlayer();
    }

    function joinTournament() external payable {
        target.joinTournament{value: msg.value}(tournamentId);
    }

    // Fallback to exploit reentrancy
    receive() external payable {
        if (address(target).balance > 0 && attackCount < maxAttacks) {
            attackCount++;
            try target.cancelTournament(tournamentId, "Fake reason") {} catch {}
        }
    }
}

contract ExploitTests is Test {
    TournamentManager public tournamentManager;
    PlayerBadge public playerBadge;

    MaliciousToken public evilToken;
    ReentrancyAttacker public attacker;

    address public owner;
    address public player1;
    address public player2;
    address public maliciousPlayer;

    uint256 constant ENTRY_FEE = 0.1 ether;
    uint256 constant TOKEN_ENTRY_FEE = 100 * 10 ** 18;

    function setUp() public {
        owner = address(this);
        player1 = makeAddr("player1");
        player2 = makeAddr("player2");
        maliciousPlayer = makeAddr("malicious");

        // Fund accounts
        vm.deal(player1, 10 ether);
        vm.deal(player2, 10 ether);
        vm.deal(maliciousPlayer, 10 ether);

        // Create standard contracts
        playerBadge = new PlayerBadge("Player Badge", "PBADGE", "https://example.com/badge/", 20);
        tournamentManager = new TournamentManager(address(playerBadge));

        // Create malicious contracts
        evilToken = new MaliciousToken(maliciousPlayer);
        attacker = new ReentrancyAttacker(tournamentManager);
    }

    /* ========== FUZZING TESTS ========== */

    function testFuzz_CreateTournamentWithRandomValues(
        uint256 entryFee,
        uint256 maxPlayers,
        uint256 startTime,
        uint256 duration
    ) public {
        // Bound the fuzz inputs to reasonable ranges
        entryFee = bound(entryFee, 0, 100 ether);
        maxPlayers = bound(maxPlayers, 0, 1000);
        startTime = bound(startTime, block.timestamp + 1, block.timestamp + 365 days);
        duration = bound(duration, 0, 30 days);

        if (maxPlayers <= 1) {
            vm.expectRevert();
        }

        try tournamentManager.createTournament(
            "Fuzzy Tournament", entryFee, address(0), maxPlayers, startTime, duration
        ) {
            // If it succeeds, verify the tournament was created properly
            if (maxPlayers > 1) {
                uint256 tournamentId = 1; // First tournament should have ID 1
                (
                    string memory name,
                    uint256 storedEntryFee,
                    address tokenAddress,
                    ,
                    uint256 storedMaxPlayers,
                    uint256 storedStartTime,
                    uint256 endTime,
                    ,
                    ,
                    ,
                    ,
                ) = tournamentManager.getTournamentDetails(tournamentId);

                assertEq(name, "Fuzzy Tournament");
                assertEq(storedEntryFee, entryFee);
                assertEq(tokenAddress, address(0));
                assertEq(storedMaxPlayers, maxPlayers);
                assertEq(storedStartTime, startTime);

                if (duration > 0) {
                    assertEq(endTime, startTime + duration);
                } else {
                    assertEq(endTime, startTime + tournamentManager.TOURNAMENT_DURATION());
                }
            }
        } catch Error(string memory reason) {
            // Check that failures are due to expected reasons
            if (maxPlayers > 1 && startTime > block.timestamp) {
                console.log("Unexpected revert: ", reason);
                revert();
            }
        }
    }

    function testFuzz_ScoreManipulation(uint256 score1, uint256 score2) public {
        // Create a tournament
        tournamentManager.createTournament(
            "Score Manipulation Test", ENTRY_FEE, address(0), 2, block.timestamp + 1 hours, 2 hours
        );

        // Register and join with players
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        vm.startPrank(player2);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        // Try to submit extreme scores
        // Should handle all possible uint256 values without overflow
        tournamentManager.submitScore(1, player1, score1);
        tournamentManager.submitScore(1, player2, score2);

        // Skip to after tournament end
        vm.warp(block.timestamp + 3 hours);

        // End tournament and check that sorting works correctly
        tournamentManager.endTournament(1);

        // Get winners and check they're correctly sorted
        address[] memory winners = tournamentManager.getTournamentWinners(1);
        assertEq(winners.length, 2);

        if (score1 > score2) {
            assertEq(winners[0], player1);
            assertEq(winners[1], player2);
        } else if (score2 > score1) {
            assertEq(winners[0], player2);
            assertEq(winners[1], player1);
        }
        // Scores are equal - order depends on implementation
    }

    /* ========== REENTRANCY ATTACK TESTS ========== */

    function testReentrancyAttack_ETHRefund() public {
        // Create tournament
        uint256 startTime = block.timestamp + 1 hours;
        tournamentManager.createTournament("Reentrancy Tournament", ENTRY_FEE, address(0), 4, startTime, 2 hours);

        // Register attacker contract
        vm.deal(address(attacker), 1 ether);
        attacker.setup(1, 3); // Tournament 1, max 3 reentrant calls
        attacker.register();

        // Join tournament with attacker
        vm.prank(address(this));
        attacker.joinTournament{value: ENTRY_FEE}();

        // Register and join with player1 as well
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        // Measure balances before attack
        uint256 attackerBalanceBefore = address(attacker).balance;
        uint256 contractBalanceBefore = address(tournamentManager).balance;

        // Execute the attack - cancel tournament which sends ETH to attacker contract
        tournamentManager.cancelTournament(1, "Trigger reentrancy");

        // Check if the attacker was able to drain more funds than it should
        uint256 attackerBalanceAfter = address(attacker).balance;
        uint256 contractBalanceAfter = address(tournamentManager).balance;

        console.log("Attacker balance before:", attackerBalanceBefore);
        console.log("Attacker balance after:", attackerBalanceAfter);
        console.log("Contract balance before:", contractBalanceBefore);
        console.log("Contract balance after:", contractBalanceAfter);
        console.log("Attacker reentrant call count:", attacker.attackCount());

        // If reentrancy protection works, attacker should only get its own entry fee back
        assertEq(attackerBalanceAfter, attackerBalanceBefore + ENTRY_FEE);
    }

    function testReentrancyAttack_TokenRefund() public {
        // Setup evil token with a reference to the tournament
        vm.startPrank(maliciousPlayer);
        evilToken.setTarget(tournamentManager, 1);
        vm.stopPrank();

        // Create tournament with evil token
        tournamentManager.createTournament(
            "Evil Token Tournament", TOKEN_ENTRY_FEE, address(evilToken), 3, block.timestamp + 1 hours, 2 hours
        );

        // Register and join with malicious player
        vm.startPrank(maliciousPlayer);
        tournamentManager.registerPlayer();
        evilToken.approve(address(tournamentManager), TOKEN_ENTRY_FEE);
        tournamentManager.joinTournament(1);
        vm.stopPrank();

        // Register and join with normal players
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        vm.stopPrank();

        vm.startPrank(player2);
        tournamentManager.registerPlayer();
        vm.stopPrank();

        // We need to transfer some evil tokens to players
        vm.startPrank(maliciousPlayer);
        evilToken.transfer(player1, TOKEN_ENTRY_FEE);
        evilToken.transfer(player2, TOKEN_ENTRY_FEE);
        vm.stopPrank();

        // Join with other players
        vm.startPrank(player1);
        evilToken.approve(address(tournamentManager), TOKEN_ENTRY_FEE);
        tournamentManager.joinTournament(1);
        vm.stopPrank();

        vm.startPrank(player2);
        evilToken.approve(address(tournamentManager), TOKEN_ENTRY_FEE);
        tournamentManager.joinTournament(1);
        vm.stopPrank();

        // Submit scores (tournament should be in progress as it's full)
        tournamentManager.submitScore(1, maliciousPlayer, 100);
        tournamentManager.submitScore(1, player1, 200);
        tournamentManager.submitScore(1, player2, 50);

        // Skip to after tournament end
        vm.warp(block.timestamp + 3 hours);

        // End tournament
        tournamentManager.endTournament(1);

        // Try to distribute prizes (this should trigger the malicious token's reentrancy)
        tournamentManager.distributePrizes(1);

        // Check if prizes were distributed correctly despite the attack
        (,,,,,,,,,, TournamentManager.TournamentStatus status, bool prizesDistributed) =
            tournamentManager.getTournamentDetails(1);

        assertEq(uint256(status), uint256(TournamentManager.TournamentStatus.Completed));
        assertEq(prizesDistributed, true);
    }

    /* ========== EDGE CASE TESTS ========== */

    function testEdgeCase_FeeOverflow() public {
        // Try to create tournament with max uint256 entry fee
        uint256 maxEntryFee = type(uint256).max;

        tournamentManager.createTournament(
            "Overflow Tournament", maxEntryFee, address(0), 3, block.timestamp + 1 hours, 2 hours
        );

        // Register players
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        vm.stopPrank();

        // Try to join (should revert because player can't send that much ETH)
        vm.startPrank(player1);
        vm.expectRevert();
        tournamentManager.joinTournament{value: maxEntryFee}(1);
        vm.stopPrank();
    }

    function testEdgeCase_ZeroFee() public {
        // Create tournament with zero entry fee
        tournamentManager.createTournament("Free Tournament", 0, address(0), 3, block.timestamp + 1 hours, 2 hours);

        // Register and join players
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament(1); // No value needed
        vm.stopPrank();

        vm.startPrank(player2);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament(1);
        vm.stopPrank();

        vm.startPrank(makeAddr("player3"));
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament(1);
        vm.stopPrank();

        vm.warp(block.timestamp + 2 hours);

        // Complete tournament and distribute prizes
        tournamentManager.submitScore(1, player1, 100);
        tournamentManager.submitScore(1, player2, 200);

        vm.warp(block.timestamp + 3 hours);
        tournamentManager.endTournament(1);

        // Distribution should work even with zero prize pool
        tournamentManager.distributePrizes(1);

        // Verify distribution is marked as complete
        (,,,,,,,,,, TournamentManager.TournamentStatus status, bool prizesDistributed) =
            tournamentManager.getTournamentDetails(1);

        assertEq(uint256(status), uint256(TournamentManager.TournamentStatus.Completed));
        assertEq(prizesDistributed, true);
    }

    function testEdgeCase_DiscountManipulation() public {
        // Create tournament
        tournamentManager.createTournament(
            "Discount Exploit", ENTRY_FEE, address(0), 2, block.timestamp + 1 hours, 2 hours
        );

        // Set extreme discount
        playerBadge.setDiscountPercentage(99);

        // Register player1 and mint badge
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        vm.stopPrank();
        playerBadge.mintBadge(player1);

        // Join with 99% discount
        vm.startPrank(player1);
        uint256 discountedFee = ENTRY_FEE * 1 / 100; // 99% off
        tournamentManager.joinTournament{value: discountedFee}(1);
        vm.stopPrank();

        // Verify player joined with tiny fee
        bool hasJoined = tournamentManager.hasPlayerJoined(1, player1);
        assertEq(hasJoined, true);

        // Try setting 100% discount (edge case)
        playerBadge.setDiscountPercentage(100);

        // Register player2 and mint badge
        vm.startPrank(player2);
        tournamentManager.registerPlayer();
        vm.stopPrank();
        playerBadge.mintBadge(player2);

        // Join with 100% discount (should need 0 fee)
        vm.startPrank(player2);
        tournamentManager.joinTournament(1); // No value needed
        vm.stopPrank();

        // Verify both players in tournament
        hasJoined = tournamentManager.hasPlayerJoined(1, player2);
        assertEq(hasJoined, true);
    }

    function testEdgeCase_MismatchedArrays() public {
        // Create tournament
        tournamentManager.createTournament(
            "Mismatched Arrays", ENTRY_FEE, address(0), 3, block.timestamp + 1 hours, 2 hours
        );

        // Register players
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        vm.startPrank(player2);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        vm.startPrank(maliciousPlayer);
        tournamentManager.registerPlayer();
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        // Try to submit scores with mismatched arrays
        address[] memory players = new address[](3);
        players[0] = player1;
        players[1] = player2;
        players[2] = maliciousPlayer;

        uint256[] memory scores = new uint256[](2); // One less than players
        scores[0] = 100;
        scores[1] = 200;

        vm.expectRevert();
        tournamentManager.submitScoresBatch(1, players, scores);

        // Try with empty arrays
        address[] memory emptyPlayers = new address[](0);
        uint256[] memory emptyScores = new uint256[](0);

        vm.expectRevert();
        tournamentManager.submitScoresBatch(1, emptyPlayers, emptyScores);
    }

    function testEdgeCase_InvalidTournamentAccess() public {
        // Register a player first
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        vm.stopPrank();

        // Now try to access non-existent tournament
        vm.startPrank(player1);
        vm.expectRevert();
        tournamentManager.joinTournament{value: ENTRY_FEE}(999);
        vm.stopPrank();

        // Create tournament and try to submit scores without correct status
        tournamentManager.createTournament(
            "Invalid Status", ENTRY_FEE, address(0), 2, block.timestamp + 1 hours, 2 hours
        );

        // Try to submit score while tournament is still open (not in progress)
        vm.expectRevert();
        tournamentManager.submitScore(1, player1, 100);

        // Try to end tournament that hasn't started
        vm.expectRevert();
        tournamentManager.endTournament(1);

        // Skip to tournament start and try to distribute prizes before completion
        vm.warp(block.timestamp + 1 hours);
        vm.expectRevert();
        tournamentManager.distributePrizes(1);
    }

    function testEdgeCase_BlockTimestampManipulation() public {
        // First, ensure we're starting with a safe timestamp
        vm.warp(1000000); // Start with a safer base timestamp

        // Create tournament with a relative start time
        uint256 startTime = block.timestamp + 1 hours;
        uint256 backTime = startTime - 10;
        tournamentManager.createTournament("Timestamp Tournament", ENTRY_FEE, address(0), 2, startTime, 2 hours);

        // Register players
        vm.startPrank(player1);
        tournamentManager.registerPlayer();
        vm.stopPrank();

        vm.startPrank(player2);
        tournamentManager.registerPlayer();
        vm.stopPrank();

        // Try to join exactly at the start time
        vm.warp(startTime);

        vm.startPrank(player1);
        // Contract check is block.timestamp < startTime, not <=
        vm.expectRevert();
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        // Reset to before start time and join
        vm.warp(backTime); // More than 1 second for safety
        // Join with both players to put tournament in progress
        vm.startPrank(player1);
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        vm.startPrank(player2);
        tournamentManager.joinTournament{value: ENTRY_FEE}(1);
        vm.stopPrank();

        // Verify tournament is in progress
        (,,,,,,,,,, TournamentManager.TournamentStatus status,) = tournamentManager.getTournamentDetails(1);
        assertEq(uint256(status), uint256(TournamentManager.TournamentStatus.InProgress));

        // Submit scores
        tournamentManager.submitScore(1, player1, 100);
        tournamentManager.submitScore(1, player2, 200);

        // Try to end tournament at exactly the end time
        uint256 endTime = startTime + 2 hours;
        vm.warp(endTime);

        // End tournament (should work at exactly end time)
        tournamentManager.endTournament(1);

        // Verify tournament status
        (,,,,,,,,,, status,) = tournamentManager.getTournamentDetails(1);
        assertEq(uint256(status), uint256(TournamentManager.TournamentStatus.Completed));
    }
}
